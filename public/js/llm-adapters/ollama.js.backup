// Ollama Adapter (Qwen2 0.5B on OVH AI Deploy)
import { SpatialAnalysis } from '../spatial-analysis.js';

const OllamaAdapter = {
    name: 'Ollama Llama3.2 3B',
    model: 'llama3.2:3b',  // Mod√®le plus l√©ger et plus rapide
    maxTokens: 1000,  // Limit√© pour √©viter les timeouts (20-25 pixels par it√©ration)
    
    // Configuration par d√©faut
    config: {
        model: 'llama3.2:3b',
        max_tokens: 1000
    },
    
    // ============================================
    // CONVERSION DE COULEURS (RVB9 ‚Üî HEX)
    // ============================================
    
    // Pas de palette pr√©-calcul√©e : le LLM choisit ses couleurs librement
    
    // Fonction helper pour g√©n√©rer une palette de secours (SUPPRIM√âE - non utilis√©e)
    // generateColorPalette: () => {
        const techniques = [
            {
                name: 'Monochromatique (ombres/lumi√®res)',
                description: 'D√©grad√©s d\'une couleur: noir ‚Üí blanc',
                generate: () => {
                    const hue = Math.random() * 360;
                    return [
                        OllamaAdapter.hslToHex(hue, 80, 8),   // TR√àS sombre (presque noir)
                        OllamaAdapter.hslToHex(hue, 75, 18),  // Ombre profonde
                        OllamaAdapter.hslToHex(hue, 70, 28),  // Ombre moyenne
                        OllamaAdapter.hslToHex(hue, 65, 40),  // Base fonc√©e
                        OllamaAdapter.hslToHex(hue, 60, 50),  // Base
                        OllamaAdapter.hslToHex(hue, 55, 60),  // Lumi√®re moyenne
                        OllamaAdapter.hslToHex(hue, 50, 70),  // Lumi√®re claire
                        OllamaAdapter.hslToHex(hue, 40, 78),  // Highlight
                        OllamaAdapter.hslToHex(hue, 30, 86),  // Highlight fort
                        OllamaAdapter.hslToHex(hue, 20, 93),  // Presque blanc
                        OllamaAdapter.hslToHex(hue, 10, 97),  // TR√àS clair
                        OllamaAdapter.hslToHex(hue, 0, 100)   // Blanc pur
                    ];
                }
            },
            {
                name: 'Compl√©mentaires (contraste maximal)',
                description: 'Deux couleurs oppos√©es: du noir au blanc',
                generate: () => {
                    const hue1 = Math.random() * 360;
                    const hue2 = (hue1 + 180) % 360;  // Oppos√© sur le cercle
                    return [
                        OllamaAdapter.hslToHex(hue1, 90, 5),   // Couleur 1 TR√àS fonc√©e
                        OllamaAdapter.hslToHex(hue1, 80, 20),  // Couleur 1 fonc√©e
                        OllamaAdapter.hslToHex(hue1, 70, 40),  // Couleur 1 moyenne
                        OllamaAdapter.hslToHex(hue1, 60, 60),  // Couleur 1 claire
                        OllamaAdapter.hslToHex(hue1, 40, 80),  // Couleur 1 tr√®s claire
                        OllamaAdapter.hslToHex(hue1, 20, 95),  // Couleur 1 presque blanc
                        OllamaAdapter.hslToHex(hue2, 90, 5),   // Couleur 2 TR√àS fonc√©e
                        OllamaAdapter.hslToHex(hue2, 80, 20),  // Couleur 2 fonc√©e
                        OllamaAdapter.hslToHex(hue2, 70, 40),  // Couleur 2 moyenne
                        OllamaAdapter.hslToHex(hue2, 60, 60),  // Couleur 2 claire
                        OllamaAdapter.hslToHex(hue2, 40, 80),  // Couleur 2 tr√®s claire
                        OllamaAdapter.hslToHex(hue2, 20, 95)   // Couleur 2 presque blanc
                    ];
                }
            },
            {
                name: 'Triade (profondeur)',
                description: '3 couleurs espac√©es: ombres profondes + lumi√®res vives',
                generate: () => {
                    const hue1 = Math.random() * 360;
                    const hue2 = (hue1 + 120) % 360;
                    const hue3 = (hue1 + 240) % 360;
                    return [
                        OllamaAdapter.hslToHex(hue1, 85, 10),  // Couleur 1 tr√®s fonc√©e
                        OllamaAdapter.hslToHex(hue1, 75, 25),  // Couleur 1 fonc√©e
                        OllamaAdapter.hslToHex(hue1, 65, 50),  // Couleur 1 moyenne
                        OllamaAdapter.hslToHex(hue1, 45, 80),  // Couleur 1 claire
                        OllamaAdapter.hslToHex(hue2, 85, 10),  // Couleur 2 tr√®s fonc√©e
                        OllamaAdapter.hslToHex(hue2, 75, 25),  // Couleur 2 fonc√©e
                        OllamaAdapter.hslToHex(hue2, 65, 50),  // Couleur 2 moyenne
                        OllamaAdapter.hslToHex(hue2, 45, 80),  // Couleur 2 claire
                        OllamaAdapter.hslToHex(hue3, 85, 10),  // Couleur 3 tr√®s fonc√©e
                        OllamaAdapter.hslToHex(hue3, 75, 25),  // Couleur 3 fonc√©e
                        OllamaAdapter.hslToHex(hue3, 65, 50),  // Couleur 3 moyenne
                        OllamaAdapter.hslToHex(hue3, 45, 80)   // Couleur 3 claire
                    ];
                }
            },
            {
                name: 'Analogues (douceur √©tendue)',
                description: 'Couleurs voisines: du sombre au lumineux',
                generate: () => {
                    const hueBase = Math.random() * 360;
                    return [
                        OllamaAdapter.hslToHex((hueBase - 30) % 360, 80, 12),  // Tr√®s fonc√©
                        OllamaAdapter.hslToHex((hueBase - 20) % 360, 75, 25),  // Fonc√©
                        OllamaAdapter.hslToHex((hueBase - 10) % 360, 70, 35),  // Moyen-fonc√©
                        OllamaAdapter.hslToHex(hueBase, 70, 45),               // Base
                        OllamaAdapter.hslToHex(hueBase, 60, 55),               // Base claire
                        OllamaAdapter.hslToHex((hueBase + 10) % 360, 60, 65),  // Clair
                        OllamaAdapter.hslToHex((hueBase + 20) % 360, 55, 75),  // Tr√®s clair
                        OllamaAdapter.hslToHex((hueBase + 30) % 360, 50, 82),  // Lumineux
                        OllamaAdapter.hslToHex((hueBase + 40) % 360, 40, 88),  // Tr√®s lumineux
                        OllamaAdapter.hslToHex((hueBase + 50) % 360, 30, 92),  // Presque blanc
                        OllamaAdapter.hslToHex((hueBase + 60) % 360, 20, 96),  // Blanc teint√©
                        OllamaAdapter.hslToHex((hueBase + 70) % 360, 10, 98)   // Blanc presque pur
                    ];
                }
            },
            {
                name: 'Chaud‚ÜíFroid (ombres et lumi√®res)',
                description: 'Chaud (avant, sombre) ‚Üí Froid (arri√®re, lumineux)',
                generate: () => {
                    return [
                        OllamaAdapter.hslToHex(0, 90, 10),     // Rouge tr√®s sombre
                        OllamaAdapter.hslToHex(15, 85, 25),    // Rouge-orange fonc√©
                        OllamaAdapter.hslToHex(25, 80, 40),    // Orange
                        OllamaAdapter.hslToHex(40, 75, 55),    // Jaune-orange
                        OllamaAdapter.hslToHex(55, 70, 68),    // Jaune clair
                        OllamaAdapter.hslToHex(70, 60, 78),    // Jaune-vert lumineux
                        OllamaAdapter.hslToHex(180, 55, 65),   // Cyan (transition)
                        OllamaAdapter.hslToHex(200, 65, 55),   // Bleu-cyan
                        OllamaAdapter.hslToHex(220, 75, 45),   // Bleu
                        OllamaAdapter.hslToHex(240, 80, 35),   // Bleu fonc√©
                        OllamaAdapter.hslToHex(260, 85, 22),   // Bleu-violet profond
                        OllamaAdapter.hslToHex(280, 90, 12)    // Violet TR√àS sombre
                    ];
                }
            },
            {
                name: 'Noir et Blanc + Accent',
                description: 'Monochrome avec 1 couleur vive pour accent',
                generate: () => {
                    const accentHue = Math.random() * 360;
                    return [
                        '#000000',  // Noir pur
                        OllamaAdapter.hslToHex(0, 0, 15),      // Gris tr√®s fonc√©
                        OllamaAdapter.hslToHex(0, 0, 30),      // Gris fonc√©
                        OllamaAdapter.hslToHex(0, 0, 45),      // Gris moyen
                        OllamaAdapter.hslToHex(0, 0, 60),      // Gris clair
                        OllamaAdapter.hslToHex(0, 0, 75),      // Gris tr√®s clair
                        OllamaAdapter.hslToHex(0, 0, 90),      // Presque blanc
                        '#FFFFFF',  // Blanc pur
                        OllamaAdapter.hslToHex(accentHue, 95, 25),  // Accent fonc√©
                        OllamaAdapter.hslToHex(accentHue, 90, 45),  // Accent moyen
                        OllamaAdapter.hslToHex(accentHue, 85, 60),  // Accent clair
                        OllamaAdapter.hslToHex(accentHue, 75, 75)   // Accent lumineux
                    ];
                }
            }
        ];
        
        // Choisir une technique al√©atoire
        const technique = techniques[Math.floor(Math.random() * techniques.length)];
        const palette = technique.generate();
        
        console.log(`üé® [Palette] Technique: "${technique.name}" - ${technique.description}`);
        
        return { colors: palette, technique: technique };
    },
    
    // Conversion HSL vers Hex (helper simplifi√©)
    hslToHex: (h, s, l) => {
        const rgb = OllamaAdapter.hslToRgb(h, s, l);
        return `#${rgb.r.toString(16).padStart(2, '0')}${rgb.g.toString(16).padStart(2, '0')}${rgb.b.toString(16).padStart(2, '0')}`.toUpperCase();
    },
    
    // Conversion HSL vers RGB
    hslToRgb: (h, s, l) => {
        s /= 100;
        l /= 100;
        const c = (1 - Math.abs(2 * l - 1)) * s;
        const x = c * (1 - Math.abs((h / 60) % 2 - 1));
        const m = l - c / 2;
        let r = 0, g = 0, b = 0;
        
        if (h < 60) { r = c; g = x; b = 0; }
        else if (h < 120) { r = x; g = c; b = 0; }
        else if (h < 180) { r = 0; g = c; b = x; }
        else if (h < 240) { r = 0; g = x; b = c; }
        else if (h < 300) { r = x; g = 0; b = c; }
        else { r = c; g = 0; b = x; }
        
        return {
            r: Math.round((r + m) * 255),
            g: Math.round((g + m) * 255),
            b: Math.round((b + m) * 255)
        };
    },

    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    // FORMAT RVB 0-9 : Conversion ultra-compacte pour √©conomiser les tokens
    // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    // Convertir #RRGGBB ‚Üí RVB (ex: #3498DB ‚Üí 349)
    hexToRGB9: (hex) => {
        if (!hex || hex.length !== 7) return '000';
        const r = Math.round(parseInt(hex.substr(1, 2), 16) / 255 * 9);
        const g = Math.round(parseInt(hex.substr(3, 2), 16) / 255 * 9);
        const b = Math.round(parseInt(hex.substr(5, 2), 16) / 255 * 9);
        return `${r}${g}${b}`;
    },
    
    // Convertir RVB ‚Üí #RRGGBB (ex: 349 ‚Üí #3399DD)
    rgb9ToHex: (rgb9) => {
        if (!rgb9 || rgb9.length !== 3) return '#000000';
        const r = Math.round(parseInt(rgb9[0]) / 9 * 255).toString(16).padStart(2, '0');
        const g = Math.round(parseInt(rgb9[1]) / 9 * 255).toString(16).padStart(2, '0');
        const b = Math.round(parseInt(rgb9[2]) / 9 * 255).toString(16).padStart(2, '0');
        return `#${r}${g}${b}`.toUpperCase();
    },
    
    // Convertir une grille 20√ó20 (avec hex) en format RVB9 tableau compact
    gridToRGB9Table: (grid, userId) => {
        if (!grid || grid.length !== 20 || grid[0].length !== 20) {
            // G√©n√©rer une grille vide
            return Array(20).fill(null).map(() => 
                Array(20).fill('000').join(' ')
            ).join('\n');
        }
        
        const lines = [];
        for (let y = 0; y < 20; y++) {
            const row = [];
            for (let x = 0; x < 20; x++) {
                const hex = grid[y][x] || '#000000';
                row.push(OllamaAdapter.hexToRGB9(hex));
            }
            lines.push(row.join(' '));
        }
        return lines.join('\n');
    },

    // Construire le prompt pour l'analyse du manuel (1√®re requ√™te, VERSION ULTRA-SIMPLIFI√âE)
    buildManualAnalysisPrompt: (manualContent) => {
        // Exemples concrets vari√©s (pas de manuel complexe)
        const exemples = [
            {
                forme: "cercle vert",
                pixels: "8,5:#2ECC71 9,5:#2ECC71 7,6:#2ECC71 10,6:#2ECC71 6,7:#2ECC71 11,7:#2ECC71 6,8:#2ECC71 11,8:#2ECC71 7,9:#2ECC71 10,9:#2ECC71 8,10:#2ECC71 9,10:#2ECC71 8,6:#58D68D 9,6:#58D68D 8,7:#58D68D 9,7:#58D68D 8,8:#58D68D 9,8:#58D68D 8,9:#58D68D 9,9:#58D68D"
            },
            {
                forme: "croix rouge",
                pixels: "8,2:#E74C3C 8,3:#E74C3C 8,4:#E74C3C 8,5:#E74C3C 8,6:#E74C3C 2,5:#E74C3C 3,5:#E74C3C 4,5:#E74C3C 5,5:#E74C3C 6,5:#E74C3C 9,5:#E74C3C 10,5:#E74C3C 11,5:#E74C3C 7,5:#C85A3F 9,4:#C85A3F 7,6:#C85A3F 9,6:#C85A3F"
            },
            {
                forme: "lettre H bleue",
                pixels: "5,3:#3498DB 5,4:#3498DB 5,5:#3498DB 5,6:#3498DB 5,7:#3498DB 6,5:#5DADE2 7,5:#5DADE2 8,5:#5DADE2 9,3:#3498DB 9,4:#3498DB 9,5:#3498DB 9,6:#3498DB 9,7:#3498DB 6,6:#5DADE2 7,6:#5DADE2 8,6:#5DADE2"
            },
            {
                forme: "triangle orange",
                pixels: "8,3:#F39C12 7,4:#F39C12 8,4:#F39C12 9,4:#F39C12 6,5:#F39C12 7,5:#F39C12 8,5:#F39C12 9,5:#F39C12 10,5:#F39C12 5,6:#E67E22 6,6:#E67E22 7,6:#E67E22 8,6:#E67E22 9,6:#E67E22 10,6:#E67E22 11,6:#E67E22"
            },
            {
                forme: "damier violet",
                pixels: "5,5:#9B59B6 7,5:#9B59B6 9,5:#9B59B6 11,5:#9B59B6 6,6:#E91E63 8,6:#E91E63 10,6:#E91E63 12,6:#E91E63 5,7:#9B59B6 7,7:#9B59B6 9,7:#9B59B6 11,7:#9B59B6 6,8:#E91E63 8,8:#E91E63 10,8:#E91E63"
            }
        ];
        
        const exemple = exemples[Math.floor(Math.random() * exemples.length)];
        
        return `DESSINE 25 pixels. Format: x,y:#RRGGBB (espaces entre pixels)

EXEMPLE:
strategy: ${exemple.forme}
pixels: ${exemple.pixels}

TOI - COPIE CE FORMAT (pas de texte, juste strategy + pixels):
strategy:`;
    },

    // Calculer des transformations g√©om√©triques (miroir, translation, rotation)
    computeTransformations: (pixels, direction) => {
        if (!pixels || pixels.length === 0) return [];
        
        const transformations = [];
        
        // STRAT√âGIE POROSIT√â: Prendre seulement 2-4 pixels CL√âS du voisin,
        // pas toute la bordure, pour cr√©er une connexion subtile
        
        // DEBUG: Log les coordonn√©es des pixels re√ßus
        const pixelCoords = pixels.map(p => `(${p.x},${p.y})`).slice(0, 5).join(' ');
        
        // Filtrer les pixels qui sont vraiment AUX BORDURES du voisin
        let borderPixels = [];
        
        if (direction === 'W') {
            // Voisin √† l'OUEST ‚Üí prendre ses pixels √† x >= 17 (sa bordure droite qui touche ma gauche)
            borderPixels = pixels.filter(p => p.x >= 17);
            console.log(`[Transform] ${direction}: ${pixels.length} pixels ‚Üí ${borderPixels.length} aux bordures (x>=17). Sample: ${pixelCoords}`);
            if (borderPixels.length > 0) {
                // Prendre 2-3 pixels al√©atoires (ou les plus int√©ressants)
                const sample = borderPixels.slice(0, 3);
                const prolongement = sample.map(p => ({
                    x: p.x - 17,  // x=17‚Üí0, x=18‚Üí1, x=19‚Üí2
                    y: p.y,
                    color: p.color
                })).filter(p => p.x >= 0 && p.x < 20 && p.y >= 0 && p.y < 20);
                
                if (prolongement.length > 0) {
                    transformations.push({ type: 'Quelques pixels du voisin W', pixels: prolongement });
                }
            }
        } else if (direction === 'E') {
            // Voisin √† l'EST ‚Üí prendre ses pixels √† x <= 2 (sa bordure gauche qui touche ma droite)
            borderPixels = pixels.filter(p => p.x <= 2);
            console.log(`[Transform] ${direction}: ${pixels.length} pixels ‚Üí ${borderPixels.length} aux bordures (x<=2). Sample: ${pixelCoords}`);
            if (borderPixels.length > 0) {
                const sample = borderPixels.slice(0, 3);
                const prolongement = sample.map(p => ({
                    x: p.x + 17,  // x=0‚Üí17, x=1‚Üí18, x=2‚Üí19
                    y: p.y,
                    color: p.color
                })).filter(p => p.x >= 0 && p.x < 20 && p.y >= 0 && p.y < 20);
                
                if (prolongement.length > 0) {
                    transformations.push({ type: 'Quelques pixels du voisin E', pixels: prolongement });
                }
            }
        } else if (direction === 'N') {
            // Voisin au NORD ‚Üí prendre ses pixels √† y >= 17 (sa bordure basse qui touche mon haut)
            borderPixels = pixels.filter(p => p.y >= 17);
            if (borderPixels.length > 0) {
                const sample = borderPixels.slice(0, 3);
                const prolongement = sample.map(p => ({
                    x: p.x,
                    y: p.y - 17,  // y=17‚Üí0, y=18‚Üí1, y=19‚Üí2
                    color: p.color
                })).filter(p => p.x >= 0 && p.x < 20 && p.y >= 0 && p.y < 20);
                
                if (prolongement.length > 0) {
                    transformations.push({ type: 'Quelques pixels du voisin N', pixels: prolongement });
                }
            }
        } else if (direction === 'S') {
            // Voisin au SUD ‚Üí prendre ses pixels √† y <= 2 (sa bordure haute qui touche mon bas)
            borderPixels = pixels.filter(p => p.y <= 2);
            if (borderPixels.length > 0) {
                const sample = borderPixels.slice(0, 3);
                const prolongement = sample.map(p => ({
                    x: p.x,
                    y: p.y + 17,  // y=0‚Üí17, y=1‚Üí18, y=2‚Üí19
                    color: p.color
                })).filter(p => p.x >= 0 && p.x < 20 && p.y >= 0 && p.y < 20);
                
                if (prolongement.length > 0) {
                    transformations.push({ type: 'Quelques pixels du voisin S', pixels: prolongement });
                }
            }
        } else if (direction === 'NW') {
            // Voisin NORD-OUEST ‚Üí prendre coins (x>=17 ET y>=17)
            borderPixels = pixels.filter(p => p.x >= 17 && p.y >= 17);
            if (borderPixels.length > 0) {
                const sample = borderPixels.slice(0, 2);
                const prolongement = sample.map(p => ({
                    x: p.x - 17,
                    y: p.y - 17,
                    color: p.color
                })).filter(p => p.x >= 0 && p.x < 20 && p.y >= 0 && p.y < 20);
                
                if (prolongement.length > 0) {
                    transformations.push({ type: 'Coin du voisin NW', pixels: prolongement });
                }
            }
        } else if (direction === 'NE') {
            // Voisin NORD-EST ‚Üí prendre coins (x<=2 ET y>=17)
            borderPixels = pixels.filter(p => p.x <= 2 && p.y >= 17);
            if (borderPixels.length > 0) {
                const sample = borderPixels.slice(0, 2);
                const prolongement = sample.map(p => ({
                    x: p.x + 17,
                    y: p.y - 17,
                    color: p.color
                })).filter(p => p.x >= 0 && p.x < 20 && p.y >= 0 && p.y < 20);
                
                if (prolongement.length > 0) {
                    transformations.push({ type: 'Coin du voisin NE', pixels: prolongement });
                }
            }
        } else if (direction === 'SW') {
            // Voisin SUD-OUEST ‚Üí prendre coins (x>=17 ET y<=2)
            borderPixels = pixels.filter(p => p.x >= 17 && p.y <= 2);
            if (borderPixels.length > 0) {
                const sample = borderPixels.slice(0, 2);
                const prolongement = sample.map(p => ({
                    x: p.x - 17,
                    y: p.y + 17,
                    color: p.color
                })).filter(p => p.x >= 0 && p.x < 20 && p.y >= 0 && p.y < 20);
                
                if (prolongement.length > 0) {
                    transformations.push({ type: 'Coin du voisin SW', pixels: prolongement });
                }
            }
        } else if (direction === 'SE') {
            // Voisin SUD-EST ‚Üí prendre coins (x<=2 ET y<=2)
            borderPixels = pixels.filter(p => p.x <= 2 && p.y <= 2);
            if (borderPixels.length > 0) {
                const sample = borderPixels.slice(0, 2);
                const prolongement = sample.map(p => ({
                    x: p.x + 17,
                    y: p.y + 17,
                    color: p.color
                })).filter(p => p.x >= 0 && p.x < 20 && p.y >= 0 && p.y < 20);
                
                if (prolongement.length > 0) {
                    transformations.push({ type: 'Coin du voisin SE', pixels: prolongement });
                }
            }
        }
        
        return transformations;
    },

    // Construire le prompt syst√®me (VERSION COMPACTE pour Ollama - limite 4096 tokens)
    buildSystemPrompt: (analysis, customPrompt, isFirstRequest, manualContent, iterationCount, myLastStrategy) => {
        // Construire info voisins de mani√®re ultra-compacte avec hints spatiaux
        let voisinsCompact = '';
        const spatialNeighbors = analysis.spatialNeighbors || {};
        
        // Hints de connexion spatiale (o√π regarder dans ma grille)
        const spatialHints = {
            'N': 'y=0',      // Voisin Nord touche mon y=0
            'S': 'y=19',     // Voisin Sud touche mon y=19
            'E': 'x=19',     // Voisin Est touche mon x=19
            'W': 'x=0',      // Voisin Ouest touche mon x=0
            'NE': 'x=19,y=0',
            'NW': 'x=0,y=0',
            'SE': 'x=19,y=19',
            'SW': 'x=0,y=19'
        };
        
        if (Object.keys(spatialNeighbors).length > 0) {
            const voisinsList = [];
            const suggestions = [];
            
            console.log('[Collaboration] spatialNeighbors:', Object.keys(spatialNeighbors).map(dir => 
                `${dir}: ${spatialNeighbors[dir].pixel_count}px, ${spatialNeighbors[dir].recent_updates?.length || 0} updates`
            ).join(', '));
            
            for (const [dir, n] of Object.entries(spatialNeighbors)) {
                if (n.pixel_count > 0 && n.recent_updates && n.recent_updates.length > 0) {
                    // STRAT√âGIE: Prioriser les pixels AUX BORDURES pour la collaboration
                    // 1. Filtrer d'abord pour les bordures selon la direction
                    let borderFilter = (u) => true; // Par d√©faut, tous les pixels
                    if (dir === 'W') borderFilter = (u) => u.x >= 17;
                    else if (dir === 'E') borderFilter = (u) => u.x <= 2;
                    else if (dir === 'N') borderFilter = (u) => u.y >= 17;
                    else if (dir === 'S') borderFilter = (u) => u.y <= 2;
                    else if (dir === 'NW') borderFilter = (u) => u.x >= 17 && u.y >= 17;
                    else if (dir === 'NE') borderFilter = (u) => u.x <= 2 && u.y >= 17;
                    else if (dir === 'SW') borderFilter = (u) => u.x >= 17 && u.y <= 2;
                    else if (dir === 'SE') borderFilter = (u) => u.x <= 2 && u.y <= 2;
                    
                    // 2. S√©parer pixels aux bordures et pixels centraux
                    const borderPixels = [];
                    const centralPixels = [];
                    const seen = new Set();
                    
                    for (const u of n.recent_updates) {
                        const key = `${u.x},${u.y}`;
                        if (!seen.has(key)) {
                            seen.add(key);
                            if (borderFilter(u)) {
                                borderPixels.push(u);
                            } else {
                                centralPixels.push(u);
                            }
                        }
                    }
                    
                    // 3. PRIORISER les bordures: prendre 12 bordures + 4 centraux (2 it√©rations)
                    // Objectif: garder l'historique des 2 derni√®res it√©rations (~20 pixels chacune)
                    const updates = [
                        ...borderPixels.slice(0, 12),  // Prioriser bordures
                        ...centralPixels.slice(0, 4)    // Contexte g√©n√©ral
                    ].slice(0, 16);  // Max 16 pixels (au lieu de 8)
                    
                    console.log(`[Priorisation] ${dir}: ${borderPixels.length} bordures, ${centralPixels.length} centraux ‚Üí ${updates.length} envoy√©s (2 it√©rations)`);
                    const updateStr = updates.map(u => `${u.x},${u.y}:${u.color}`).join(' ');
                    const hint = spatialHints[dir] || '';
                    
                    // Analyser les couleurs dominantes
                    const colorCounts = {};
                    updates.forEach(u => {
                        colorCounts[u.color] = (colorCounts[u.color] || 0) + 1;
                    });
                    const dominantColor = Object.keys(colorCounts).sort((a, b) => colorCounts[b] - colorCounts[a])[0];
                    
                    // Le voisin a des pixels aux bordures si on a trouv√© des borderPixels
                    const atBorder = borderPixels.length > 0;
                    const borderHint = atBorder ? ` üîóBORDURE(${borderPixels.length})` : '';
                    
                    // Info voisin
                    let info = `${dir} (touche ${hint})${borderHint}: ${updateStr}`;
                    if (n.last_strategy) {
                        info += ` ‚Üí "${n.last_strategy.substring(0, 30)}"`;
                    }
                    voisinsList.push(info);
                    
                    // NOUVEAU: Calculer des transformations g√©om√©triques possibles
                    const transformed = OllamaAdapter.computeTransformations(updates, dir);
                    if (transformed.length > 0) {
                        suggestions.push({
                            dir: dir,
                            original: updates,
                            transformed: transformed,
                            atBorder: atBorder  // Marquer si c'est une opportunit√© de bordure
                        });
                    }
                }
            }
            
            if (voisinsList.length > 0) {
                voisinsCompact = 'Neighbors:\n' + voisinsList.slice(0, 3).join('\n');
                
                console.log(`[Collaboration] It√©ration ${iterationCount} - ${voisinsList.length} voisin(s) d√©tect√©(s)`);
                
                // Ajouter des exemples de transformations NUM√âROT√âES (MAX 3 OPTIONS)
                if (suggestions.length > 0) {
                    // PRIORISER les suggestions aux bordures
                    const borderSuggestions = suggestions.filter(s => s.atBorder && s.transformed.length > 0);
                    const otherSuggestions = suggestions.filter(s => !s.atBorder && s.transformed.length > 0);
                    const prioritized = [...borderSuggestions, ...otherSuggestions];
                    
                    if (prioritized.length > 0) {
                        voisinsCompact += '\n\nCollaboration ideas (choose ONE or draw freely):';
                        let optionNum = 1;
                        
                        // Limiter √† 3 options MAXIMUM pour garder de la place aux exemples de formes
                        const maxOptions = 3;
                        for (const sugg of prioritized) {
                            if (optionNum > maxOptions) break;
                            
                            const borderTag = sugg.atBorder ? ' üîó' : '';
                            // Prendre seulement la PREMI√àRE transformation (la plus pertinente)
                            const ex = sugg.transformed[0];
                            // NOUVEAU : Format RVB9 pour les suggestions
                            const pixelsStr = ex.pixels.slice(0, 6).map(p => {
                                const rgb9 = OllamaAdapter.hexToRGB9(p.color);
                                return `${p.x},${p.y}:${rgb9}`;
                            }).join(' ');
                            voisinsCompact += `\n[${optionNum}]${borderTag} ${ex.type} from ${sugg.dir}: ${pixelsStr}`;
                            optionNum++;
                        }
                        
                        // NOUVEAU : Ajouter la GRILLE COMPL√àTE du voisin le plus actif en format RVB9
                        if (prioritized.length > 0 && prioritized[0].atBorder) {
                            const mostActiveDir = prioritized[0].dir;
                            const mostActiveNeighbor = spatialNeighbors[mostActiveDir];
                            
                            if (mostActiveNeighbor && mostActiveNeighbor.grid) {
                                const gridRGB9 = OllamaAdapter.gridToRGB9Table(mostActiveNeighbor.grid);
                                voisinsCompact += `\n\nNeighbor ${mostActiveDir} full grid (R/G/B 0-9, 0=black, 9=bright):\n${gridRGB9}`;
                                console.log(`üîç [Grille RVB9] Grille compl√®te du voisin ${mostActiveDir} ajout√©e (${gridRGB9.length} chars)`);
                            }
                        }
                        
                        const borderCount = borderSuggestions.length;
                        console.log(`ü§ù [Collaboration] ${optionNum-1} suggestions (${borderCount} aux bordures):`, 
                            prioritized.slice(0, maxOptions).map(s => {
                                const ex = s.transformed[0];
                                const pixels = ex.pixels.map(p => `${p.x},${p.y}`).join(' ');
                                return `${s.dir}${s.atBorder ? 'üîó' : ''}: ${ex.type} ‚Üí ${pixels}`;
                            }).join(' | '));
                    } else {
                        console.log('‚ÑπÔ∏è [Collaboration] Aucune transformation (voisins ne dessinent pas aux bordures communes)');
                    }
                } else {
                    console.log('‚ÑπÔ∏è [Collaboration] Voisins sans updates r√©cents');
                }
            } else {
                console.log('üö´ [Collaboration] Aucun voisin d√©tect√©');
            }
        }
        
        // Exemples de formes avec leurs pixels EN FORMAT RVB9 - VARI√âT√â MAXIMALE
        const formeExemples = [
            { nom: "turquoise spiral", pixels: "8,8:177 9,8:177 10,8:177 10,9:479 10,10:479 9,10:479 8,10:479 7,10:166 7,9:166 7,8:166 7,7:166 8,7:177 9,7:177 10,7:177 11,7:177 11,8:479 11,9:479 11,10:479" },
            { nom: "blue waves", pixels: "3,8:359 4,7:5AD 5,6:359 6,7:5AD 7,8:359 8,7:5AD 9,6:359 10,7:5AD 11,8:359 12,7:5AD 13,6:359 14,7:5AD 15,8:359 4,9:279 6,9:279 8,9:279 10,9:279 12,9:279 14,9:279" },
            { nom: "yellow star", pixels: "8,3:990 7,4:970 8,4:990 9,4:970 6,5:960 7,5:970 8,5:990 9,5:970 10,5:960 5,6:970 6,6:990 7,6:990 8,6:990 9,6:990 10,6:990 11,6:970 7,7:960 9,7:960" },
            { nom: "rainbow arc", pixels: "5,10:933 6,10:933 7,10:990 8,10:990 9,10:297 10,10:297 11,10:359 12,10:359 13,10:959 14,10:959 5,11:823 6,11:823 7,11:970 8,11:970 9,11:589 10,11:589 11,11:5AD 12,11:5AD 13,11:A79 14,11:A79" },
            { nom: "pink zigzag", pixels: "3,3:916 4,4:F69 5,5:916 6,6:F69 7,7:916 8,8:F69 9,9:916 10,10:F69 11,11:916 4,3:F69 5,4:F69 6,5:F69 7,6:F69 8,7:F69 9,8:F69 10,9:F69 11,10:F69" },
            { nom: "red heart", pixels: "6,5:933 7,5:933 9,5:933 10,5:933 5,6:933 6,6:833 7,6:833 8,6:933 9,6:833 10,6:833 11,6:933 5,7:933 6,7:833 7,7:833 8,7:833 9,7:833 10,7:833 11,7:933 6,8:933 7,8:833 8,8:833 9,8:833 10,8:933" },
            { nom: "green diamond", pixels: "8,3:297 7,4:297 8,4:589 9,4:297 6,5:297 7,5:589 8,5:589 9,5:589 10,5:297 5,6:297 6,6:589 7,6:589 8,6:589 9,6:589 10,6:589 11,6:297 6,7:297 7,7:589 8,7:589 9,7:589 10,7:297" }
        ];
        
        const exempleIdx = iterationCount % formeExemples.length;
        const exemple = formeExemples[exempleIdx];
        
        // G√©n√©rer une palette de couleurs unique pour cet agent (√† la premi√®re utilisation)
        if (!OllamaAdapter.agentColorPalette) {
            OllamaAdapter.agentColorPalette = OllamaAdapter.generateColorPalette();
            console.log('üé® [Palette] Couleurs:', OllamaAdapter.agentColorPalette.colors.join(', '));
        }
        
        // Adapter le prompt selon la pr√©sence de suggestions de collaboration
        const hasCollabIdeas = voisinsCompact && voisinsCompact.includes('Id√©es collaboration');
        
        // Int√©grer le prompt personnalis√© de l'utilisateur
        const userCustomPrompt = customPrompt && customPrompt.trim().length > 0 
            ? `\nCONSIGNE UTILISATEUR: ${customPrompt}\n` 
            : '';
        
        if (customPrompt && customPrompt.trim().length > 0) {
            console.log(`üìù [Prompt] Utilisateur: "${customPrompt}"`);
        }
        
        // Suggestion de palette avec instructions artistiques (sauf si voisins copi√©s)
        const paletteSuggestion = !hasCollabIdeas 
            ? `Colors (${OllamaAdapter.agentColorPalette.technique.name}): ${OllamaAdapter.agentColorPalette.colors.join(' ')}
Use: dark for shadows/depth, light for highlights/foreground.\n`
            : '';
        
        // Rappel de la strat√©gie pr√©c√©dente pour maintenir la coh√©rence
        const lastStrategyReminder = myLastStrategy && iterationCount > 1
            ? `Last iteration: "${myLastStrategy}". CONTINUE it OR start new.\n`
            : '';
        
        if (myLastStrategy && iterationCount > 1) {
            console.log(`üîÅ [Continuit√©] Rappel strat√©gie pr√©c√©dente: "${myLastStrategy}"`);
        }
        
        let prompt;
        if (hasCollabIdeas) {
            // PROMPT COLLABORATIF (avec voisins et grille compl√®te en RVB9)
            // Format STRICT: x,y:RVB o√π R,G,B sont 0-9 UNIQUEMENT
            prompt = `20x20 grid. x,y: 0-19 (NEVER 20). Format: x,y:RVB (R/G/B each 0-9). NO EXPLANATION.
${userCustomPrompt}${lastStrategyReminder}${voisinsCompact}

EXAMPLE (COPY THIS FORMAT EXACTLY):
strategy: ${exemple.nom}
pixels: ${exemple.pixels}

YOU (2 lines, format x,y:RVB ONLY, NOT #hex):
strategy:`;
        } else {
            // PROMPT LIBRE (sans voisins)
            prompt = `20x20 grid. Draw 20-25 pixels. x,y: 0-19 (NEVER 20). Format: x,y:RVB (R/G/B each 0-9).
${userCustomPrompt}${lastStrategyReminder}${paletteSuggestion}
EXAMPLE (COPY THIS FORMAT):
strategy: ${exemple.nom}
pixels: ${exemple.pixels}

YOU (2 lines, x,y:RVB format, NOT #hex):
strategy:`;
        }

        // Log le prompt complet si des suggestions de collaboration existent
        if (hasCollabIdeas) {
            console.log('üìã [Collaboration] Prompt envoy√© au LLM:', prompt.substring(0, 800) + '...');
        }

        return prompt;
    },

    // Appeler l'API via le proxy
    async callAPI(apiKey, systemPrompt) {
        // D√©tection automatique de l'environnement
        const AI_SERVER_URL = window.location.hostname === 'localhost' 
            ? 'http://localhost:8003'
            : 'https://ai.poietic-generator.net';
        
        const response = await fetch(`${AI_SERVER_URL}/api/llm/ollama`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                model: this.model,
                messages: [{ role: 'user', content: systemPrompt }],
                max_tokens: this.maxTokens  // Limite de tokens g√©n√©r√©s
            })
        });

        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`HTTP ${response.status}: ${errorText}`);
        }

        const data = await response.json();
        
        // Convertir au format attendu par ai-player.js (comme Anthropic)
        return {
            content: data.response || '',
            usage: {}
        };
    },

    // Parser le format compact: "strategy: ... \n pixels: x,y:#color x,y:#color"
    parseCompactFormat(text) {
        try {
            // Nettoyer le texte d'abord (enlever markdown, etc.)
            let cleanText = text
                .replace(/\*\*/g, '')  // Enlever **gras**
                .replace(/\*/g, '')    // Enlever *italique*
                .replace(/```.*?\n/g, '') // Enlever ```
                .replace(/^[>\-\*\+]\s+/gm, ''); // Enlever listes markdown
            
            // Extraire la strat√©gie (chercher n'importe o√π dans le texte)
            const strategyMatch = cleanText.match(/strategy:\s*(.+?)(?=pixels:|$)/is);
            let strategy = strategyMatch ? strategyMatch[1].trim() : "dessin";
            
            // Nettoyer la strat√©gie (premi√®re ligne seulement, max 200 chars)
            strategy = strategy.split('\n')[0].substring(0, 200).trim();
            
            // D√©tecter si l'agent mentionne une option de collaboration
            const optionMatch = strategy.match(/\[(\d+)\]/);
            const collabKeywords = ['miroir', 'translation', 'rotation', 'prolonge', 'sym√©trie', 'compl√®te', 'bordure'];
            const hasCollabKeyword = collabKeywords.some(kw => strategy.toLowerCase().includes(kw));
            
            // D√©tecter si l'agent continue sa strat√©gie pr√©c√©dente
            const continueKeywords = ['continue', 'termine', 'finit', 'compl√®te', 'ajoute', '√©tend'];
            const isContinuing = continueKeywords.some(kw => strategy.toLowerCase().includes(kw));
            
            if (optionMatch) {
                console.log(`‚úÖ [Collaboration] Agent a choisi l'option [${optionMatch[1]}]: ${strategy}`);
            } else if (hasCollabKeyword) {
                console.log(`üéØ [Collaboration] Agent mentionne une transformation: ${strategy}`);
            } else if (isContinuing) {
                console.log(`üîÅ [Continuit√©] Agent continue sa strat√©gie: ${strategy.substring(0, 60)}`);
            } else {
                console.log(`üé® [Strat√©gie] Nouveau dessin: ${strategy.substring(0, 60)}`);
            }
            
            // Extraire les pixels (chercher n'importe o√π dans le texte)
            const pixelsMatch = cleanText.match(/pixels:\s*(.+?)$/is);
            
            let pixelsStr = '';
            if (pixelsMatch) {
                pixelsStr = pixelsMatch[1].trim();
            } else {
                // Si pas de "pixels:", chercher directement des patterns x,y:#color dans tout le texte
                console.warn('[Ollama] Pas de "pixels:" trouv√©, recherche directe de patterns');
                pixelsStr = cleanText;
            }
            
            // Parser chaque pixel: "x,y:#color" OU "x,y:RVB" (format compact 0-9)
            // Pattern tol√©rant : accepte espaces, sauts de ligne
            // Exemples valides: 
            //   - "5,10:#3498DB"
            //   - "5,10:349" (RVB 0-9, 3 chiffres)
            //   - "5,10:8" (RVB raccourci: 1 chiffre ‚Üí 888)
            //   - "5,10:12" (RVB raccourci: 2 chiffres ‚Üí 112)
            const pixelPattern = /(\d+)\s*,\s*(\d+)\s*:\s*([0-9]{1,3}|#[0-9A-Fa-f]{6})/g;
            const pixels = [];
            let match;
            
            while ((match = pixelPattern.exec(pixelsStr)) !== null) {
                const x = parseInt(match[1]);
                const y = parseInt(match[2]);
                let color = match[3];
                
                // Si format RVB9 (1-3 chiffres), normaliser et convertir en hex
                if (/^\d{1,3}$/.test(color)) {
                    // Normaliser: 1 chiffre ‚Üí 3 chiffres (8 ‚Üí 888, 9 ‚Üí 999)
                    if (color.length === 1) {
                        color = color.repeat(3); // 8 ‚Üí 888
                    } else if (color.length === 2) {
                        color = color[0] + color[1] + color[0]; // 12 ‚Üí 121
                    }
                    // Convertir en hex
                    color = OllamaAdapter.rgb9ToHex(color);
                    console.log(`‚úÖ [RVB9] ${match[3]} ‚Üí ${color}`);
                } else if (color.startsWith('#')) {
                    color = color.toUpperCase();
                    console.warn(`‚ö†Ô∏è [Format] LLM a utilis√© #hex au lieu de RVB9: ${color} (accept√© pour r√©trocompatibilit√©)`);
                }
                
                // Valider les coordonn√©es (0-19)
                if (x >= 0 && x < 20 && y >= 0 && y < 20) {
                    pixels.push({
                        x: x,
                        y: y,
                        color: color
                    });
                } else {
                    console.warn(`[Ollama] Pixel ignor√© (hors grille): ${x},${y}`);
                }
            }
            
            if (pixels.length === 0) {
                console.warn('[Ollama] Aucun pixel trouv√©, retour null pour fallback');
                console.warn('[Ollama] Texte analys√©:', cleanText.substring(0, 500));
                return null;  // Permettre au fallback de g√©n√©rer des pixels par d√©faut
            }
            
            console.log(`[Ollama] Format compact pars√©: ${pixels.length} pixels, strat√©gie: "${strategy}"`);
            
            return {
                strategy: strategy,
                pixels: pixels
            };
        } catch (e) {
            console.warn('[Ollama] Erreur de parsing format compact:', e.message);
            console.warn('[Ollama] Texte re√ßu (500 premiers chars):', text.substring(0, 500));
            return null;  // Permettre au fallback de g√©n√©rer des pixels par d√©faut
        }
    },

    // Parser la r√©ponse (format compact OU JSON)
    parseResponse(content) {
        // V√©rifier que content existe
        if (!content) {
            throw new Error('R√©ponse vide du serveur Ollama');
        }
        
        // content est maintenant directement le texte de r√©ponse
        const responseText = content.trim();
        
        if (!responseText) {
            throw new Error('R√©ponse vide d\'Ollama - le mod√®le est peut-√™tre en cours de chargement');
        }
        
        console.log('[Ollama] R√©ponse brute (100 premiers chars):', responseText.substring(0, 100));
        
        // D√©tecter si le LLM pose des questions ou refuse de dessiner
        const refusPatterns = [
            /puis-je/i,
            /pourrais-je/i,
            /comment puis-je/i,
            /je ne peux pas/i,
            /je ne suis pas capable/i,
            /d√©sol√©/i,
            /excusez-moi/i,
            /je suis pr√™t/i,
            /indiquez-moi/i,
            /s'il vous pla√Æt/i,
            /pour commencer/i
        ];
        
        if (refusPatterns.some(pattern => pattern.test(responseText))) {
            console.warn('[Ollama] Le LLM refuse ou pose des questions, g√©n√©ration par d√©faut');
            // G√©n√©rer une forme par d√©faut simple
            return {
                strategy: "forme par d√©faut",
                pixels: this.generateDefaultPixels()
            };
        }
        
        // PRIORIT√â AU FORMAT COMPACT
        // Chercher "strategy:" ou "pixels:" n'importe o√π dans la r√©ponse
        if (responseText.includes('strategy:') || responseText.includes('pixels:')) {
            console.log('[Ollama] Format compact d√©tect√©');
            const result = this.parseCompactFormat(responseText);
            if (result) return result;
            // Si null, continuer vers le fallback
        }
        
        // Si commence par { ou contient "pixels":[, c'est du JSON
        if (responseText.trim().startsWith('{') || responseText.includes('"pixels":[')) {
            console.log('[Ollama] Format JSON d√©tect√©');
            try {
                return this.parseJSONFormat(responseText);
            } catch (e) {
                console.warn('[Ollama] Parsing JSON √©chou√©:', e.message);
            }
        }
        
        // Par d√©faut, essayer le format compact (plus tol√©rant)
        console.log('[Ollama] Format ind√©termin√©, essai format compact');
        const compactResult = this.parseCompactFormat(responseText);
        if (compactResult) return compactResult;
        
        // Dernier essai : JSON
        console.warn('[Ollama] Essai final: JSON');
        try {
            return this.parseJSONFormat(responseText);
        } catch (e) {
            console.warn('[Ollama] Tous les parsers ont √©chou√©, g√©n√©ration par d√©faut');
            return {
                strategy: "forme par d√©faut (LLM bavard)",
                pixels: this.generateDefaultPixels()
            };
        }
    },
    
    // G√©n√©rer des pixels par d√©faut si le parsing √©choue
    generateDefaultPixels() {
        const pixels = [];
        const startX = Math.floor(Math.random() * 10) + 3;
        const startY = Math.floor(Math.random() * 10) + 3;
        const colors = ['#E74C3C', '#3498DB', '#2ECC71', '#F39C12', '#9B59B6', '#1ABC9C', '#E91E63', '#607D8B'];
        const color1 = colors[Math.floor(Math.random() * colors.length)];
        const color2 = colors[Math.floor(Math.random() * colors.length)];
        
        // Formes vari√©es al√©atoires
        const shapeType = Math.floor(Math.random() * 4);
        
        if (shapeType === 0) {
            // Cercle
            for (let angle = 0; angle < 20; angle++) {
                const rad = (angle / 20) * Math.PI * 2;
                const x = Math.round(startX + Math.cos(rad) * 3);
                const y = Math.round(startY + Math.sin(rad) * 3);
                if (x >= 0 && x < 20 && y >= 0 && y < 20) {
                    pixels.push({ x, y, color: angle < 10 ? color1 : color2 });
                }
            }
        } else if (shapeType === 1) {
            // Croix
            for (let i = -3; i <= 3; i++) {
                pixels.push({ x: startX + i, y: startY, color: color1 });
                pixels.push({ x: startX, y: startY + i, color: color2 });
            }
        } else if (shapeType === 2) {
            // Ligne diagonale avec √©paisseur
            for (let i = 0; i < 8; i++) {
                pixels.push({ x: startX + i, y: startY + i, color: color1 });
                if (i % 2 === 0) {
                    pixels.push({ x: startX + i + 1, y: startY + i, color: color2 });
                }
            }
        } else {
            // Carr√© rempli avec d√©grad√©
            for (let y = 0; y < 5; y++) {
                for (let x = 0; x < 5; x++) {
                    const col = (x + y) % 2 === 0 ? color1 : color2;
                    pixels.push({ x: startX + x, y: startY + y, color: col });
                }
            }
        }
        
        return pixels.filter(p => p.x >= 0 && p.x < 20 && p.y >= 0 && p.y < 20);
    },
    
    // Parser le format JSON (ancien syst√®me)
    parseJSONFormat(responseText) {
        let jsonStr = responseText.trim();
        
        // Retirer les fences markdown si pr√©sentes
        if (jsonStr.startsWith('```')) {
            jsonStr = jsonStr.replace(/^```(?:json)?\n?/, '').replace(/\n?```$/, '').trim();
        }
        
        // NOUVEAU: Chercher agressivement le JSON m√™me s'il y a du texte avant
        // Chercher le premier { qui commence un objet JSON valide
        let startIdx = -1;
        let endIdx = -1;
        
        // Essayer de trouver le d√©but du JSON (chercher "strategy" ou "pixels" comme indicateurs)
        const jsonIndicators = ['"strategy"', '"pixels"', '"reasoning"'];
        for (const indicator of jsonIndicators) {
            const indicatorPos = jsonStr.indexOf(indicator);
            if (indicatorPos !== -1) {
                // Remonter jusqu'au { pr√©c√©dent
                for (let i = indicatorPos; i >= 0; i--) {
                    if (jsonStr[i] === '{') {
                        startIdx = i;
                        break;
                    }
                }
                if (startIdx !== -1) break;
            }
        }
        
        // Si pas trouv√© avec les indicateurs, chercher le premier {
        if (startIdx === -1) {
            startIdx = jsonStr.indexOf('{');
        }
        
        // Extraire le bloc JSON complet
        if (startIdx !== -1) {
            let braceCount = 0;
            for (let i = startIdx; i < jsonStr.length; i++) {
                if (jsonStr[i] === '{') braceCount++;
                if (jsonStr[i] === '}') {
                    braceCount--;
                    if (braceCount === 0) {
                        endIdx = i;
                        break;
                    }
                }
            }
            
            if (endIdx !== -1) {
                jsonStr = jsonStr.substring(startIdx, endIdx + 1);
            }
        }
        
        // CORRECTIONS JSON AGRESSIVES
        
        // 1. Ajouter des guillemets aux cl√©s non-quot√©es (bug fr√©quent des LLMs)
        jsonStr = jsonStr.replace(/([{,]\s*)([a-zA-Z_][a-zA-Z0-9_]*)\s*:/g, '$1"$2":');
        
        // 2. Corriger les virgules manquantes avant les accolades fermantes
        jsonStr = jsonStr.replace(/}\s*\n\s*{/g, '},\n{');
        jsonStr = jsonStr.replace(/}\s+{/g, '}, {');
        
        // 3. Corriger les virgules manquantes √† la fin d'un objet avant ]
        jsonStr = jsonStr.replace(/}(\s*)\]/g, '}$1]');
        
        // 4. NOUVEAU: Corriger les cha√Ænes non termin√©es (string unterminated)
        // Chercher les cha√Ænes qui ne sont pas ferm√©es correctement
        jsonStr = jsonStr.replace(/"([^"]*?)(?=\s*[,}\]])/g, '"$1"');
        
        // 5. NOUVEAU: Corriger les virgules manquantes apr√®s les valeurs
        jsonStr = jsonStr.replace(/"\s*\n\s*"/g, '",\n"');
        jsonStr = jsonStr.replace(/(\d+)\s*\n\s*"/g, '$1,\n"');
        jsonStr = jsonStr.replace(/"\s*\n\s*(\d+)/g, '",\n$1');
        
        // 6. NOUVEAU: Corriger les virgules manquantes avant les accolades fermantes
        jsonStr = jsonStr.replace(/([^,}\]])\s*}/g, '$1}');
        jsonStr = jsonStr.replace(/([^,}\]])\s*]/g, '$1]');
        
        // 7. NOUVEAU: Nettoyer les caract√®res de contr√¥le et espaces bizarres
        jsonStr = jsonStr.replace(/[\x00-\x1F\x7F]/g, '');
        jsonStr = jsonStr.replace(/\s+/g, ' ');
        
        // 8. NOUVEAU: Corriger les guillemets √©chapp√©s mal form√©s
        jsonStr = jsonStr.replace(/\\"/g, '"');
        jsonStr = jsonStr.replace(/\\\\/g, '\\');
        
        // 9. NOUVEAU: S'assurer que le JSON commence et finit correctement
        if (!jsonStr.startsWith('{')) {
            const firstBrace = jsonStr.indexOf('{');
            if (firstBrace !== -1) {
                jsonStr = jsonStr.substring(firstBrace);
            }
        }
        
        // 10. NOUVEAU: Tronquer si trop long (√©viter les r√©ponses infinies)
        if (jsonStr.length > 50000) {
            console.warn('JSON trop long, tronqu√© √† 50000 caract√®res');
            jsonStr = jsonStr.substring(0, 50000);
            // Essayer de fermer proprement
            const lastBrace = jsonStr.lastIndexOf('}');
            if (lastBrace !== -1) {
                jsonStr = jsonStr.substring(0, lastBrace + 1);
            }
        }
        
        try {
            const result = JSON.parse(jsonStr);
            
            // Validation basique du r√©sultat
            if (!result.strategy || !Array.isArray(result.pixels)) {
                throw new Error('Structure JSON invalide: manque strategy ou pixels');
            }
            
            return result;
        } catch (e) {
            console.error('Erreur de parsing JSON:', e);
            console.error('JSON re√ßu (premiers 1000 chars):', jsonStr.substring(0, 1000));
            console.error('JSON re√ßu (derniers 1000 chars):', jsonStr.substring(Math.max(0, jsonStr.length - 1000)));
            console.error('Longueur totale:', jsonStr.length);
            
            // Essayer de trouver o√π est le probl√®me
            const lines = jsonStr.split('\n');
            console.error(`Nombre de lignes: ${lines.length}`);
            
            // Afficher les lignes autour de l'erreur si possible
            if (e.message.includes('position')) {
                const match = e.message.match(/position (\d+)/);
                if (match) {
                    const pos = parseInt(match[1]);
                    const lineStart = jsonStr.lastIndexOf('\n', pos);
                    const lineEnd = jsonStr.indexOf('\n', pos);
                    const problemLine = jsonStr.substring(lineStart + 1, lineEnd === -1 ? jsonStr.length : lineEnd);
                    console.error('Ligne probl√©matique:', problemLine);
                    console.error('Position dans la ligne:', pos - lineStart - 1);
                }
            }
            
            throw new Error(`JSON invalide: ${e.message}`);
        }
    }
};

export { OllamaAdapter };

